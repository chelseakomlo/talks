% https://nymity.ch/tikz/

\documentclass[hyperref={pdfpagelabels=true},table,dvipsnames,14pt,aspectratio=169]{beamer}
\usetheme{Boadilla}
\setbeamertemplate{navigation symbols}{}

\usepackage{amsthm, amsfonts, amssymb, amsmath, graphicx}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsfonts, txfonts}
\usepackage{wasysym}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{comment}
\usepackage{cryptocode}
\urlstyle{same}
\usepackage{framed}
\FrameSep5pt

\usepackage{multicol}

%\usepackage[flushmargin]{footmisc}
%\setlength\footnotemargin{1em}

\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage{tikz}
\usepackage{tikzpeople}
\usepackage{pgfplots}
\usetikzlibrary{arrows}

\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{shapes}
\usetikzlibrary{shapes.callouts}

\usepackage{capt-of}
\beamertemplatenavigationsymbolsempty
\setbeamercovered{transparent}


\input{macros}


% Method to add an item that will appear in every slide
%\addtobeamertemplate{footline}{%
%
%  \tikz[remember picture, overlay] \fill[blue] (current page.south east)
%    rectangle ++(1cm,2cm);
%
%}{}


\pgfdeclarelayer{background}
\pgfdeclarelayer{backbackground}
\pgfdeclarelayer{foreground}
\pgfsetlayers{backbackground,background,main,foreground}   %% some additional layers for demo

\usetikzlibrary{shapes,decorations.shapes}
\tikzset{>=latex}



\makeatletter
\pgfdeclareshape{document}{
\inheritsavedanchors[from=rectangle] % this is nearly a rectangle
\inheritanchorborder[from=rectangle]
\inheritanchor[from=rectangle]{center}
\inheritanchor[from=rectangle]{north}
\inheritanchor[from=rectangle]{south}
\inheritanchor[from=rectangle]{west}
\inheritanchor[from=rectangle]{east}
% ... and possibly more
\backgroundpath{% this is new
% store lower right in xa/ya and upper right in xb/yb
\southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
\northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
% compute corner of ‘‘flipped page’’
\pgf@xc=\pgf@xb \advance\pgf@xc by-10pt % this should be a parameter
\pgf@yc=\pgf@yb \advance\pgf@yc by-10pt
% construct main path
\pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
\pgfpathlineto{\pgfpoint{\pgf@xa}{\pgf@yb}}
\pgfpathlineto{\pgfpoint{\pgf@xc}{\pgf@yb}}
\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yc}}
\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
\pgfpathclose
% add little corner
\pgfpathmoveto{\pgfpoint{\pgf@xc}{\pgf@yb}}
\pgfpathlineto{\pgfpoint{\pgf@xc}{\pgf@yc}}
\pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yc}}
\pgfpathlineto{\pgfpoint{\pgf@xc}{\pgf@yc}}
}
}
\makeatother


\usepackage{filecontents}





\title{Single and Multi-Party Signatures for Discrete-Log Based Cryptosystems}
%"ECDSA,EDDSA, and Schnor: why they differ, and why threshold signatures are sometimes hard."
\author{Chelsea Komlo, University of Waterloo}
\date[April 2022]{ University of Maryland, April 28, 2022}

\begin{document}
\setbeamertemplate{itemize items}[triangle]

\tikzstyle{doc}=[%
draw,
thick,
align=center,
color=black,
shape=document,
minimum width=12mm,
minimum height=15.2mm,
shape=document,
inner sep=2ex,
]

\begin{frame}
        \thispagestyle{empty}
        \maketitle
\end{frame}

\begin{frame}
  \huge 
  Single-Party Signatures 
\end{frame}

\begin{frame}
  \frametitle{Schnorr Signatures}

  \begin{itemize}
    \item<1-> Sigma proof of knowledge of $\sk$, where $\pk = g^\sk$. 
    \item[]
    \item<2-> Bound to a message $m$ via Fiat-Shamir. 
    \item[]
    \item<3-> Recall that a sigma proof of knowledge is a three-move protocol, where:
  \begin{enumerate}
	  \item<4->[1.] The prover is initialized with $\sk$, and a challenger with $\pk$. 
	  \item<4->[2.] The prover begins by \emph{committing} to a random nonce $r$. 
	  \item<5->[3.] The challenger then \emph{sends} a challenge $c$. 
	  \item<6->[4.] Using $r$ and $c$, the prover then \emph{outputs} a response $z$. 
	  \item<7->[5.] Using $(r, c,z, \pk)$, the challenger can finally verify that the prover indeed knows $\sk$ corresponding to $\pk$.
  \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}
  \centering
\scalebox{0.9} {
\procedure{Schnorr Identification Protocol}{
  \textbf{Signer}  \< \< \textbf{Verifier} \\
  \uncover<1-> { (\sk, \pk) \leftarrow \mathit{KeyGen()} \\ }
  \uncover<3-> { k \random \mathbb{Z}_q } \\
  \uncover<3-> { R \gets g^k \in \mathbb{G} } \\
  \uncover<4-> { \< \sendmessageright{top=\text{$R$}} \< \\ }
  \< \< \uncover<5-> { c \random \mathbb{Z}_q  \\ }
  \uncover<6-> { \< \sendmessageleft{top=\text{$c$}} \< \\ }
  \uncover<7-> { z \gets k + c \cdot \sk \\ }
  \uncover<8-> { \< \sendmessageright{top=\text{$(m, \sigma=(R, z))$}} \< \\ }
  \< \< \uncover<9-> { R' = g^z \cdot \pk^{-c'} \\ }
  \< \< \uncover<10-> { \text{Output } 1 \text{ if } R \stackrel{?}{=} R' \\ }
  \< \< \uncover<11-> { \text{Otherwise, output } 0 \\ }
}
}
\end{frame}

\begin{frame}
  \frametitle{Non-Interactive Schnorr via Fiat-Shamir}

  \begin{itemize}
    \item<1-> The Fiat-Shamir transform allows the interactive challenge step to instead be replaced by the output from a random oracle. 
    \item[]
    \item<2-> For Schnorr signatures, this challenge is also strongly bound to the message that the signature is over. 
  \end{itemize}
\end{frame}


\begin{frame}
  \centering
\scalebox{0.9} {
\procedure{Schnorr Signature Scheme}{
  \textbf{Signer}  \< \< \textbf{Verifier} \\
  \uncover<1-> { (\sk, \pk) \leftarrow \mathit{KeyGen()} \\ }
  \uncover<2-> { \< \sendmessageleft{top=\text{$m$}} \< \\ }
  \uncover<3-> { k \random \mathbb{Z}_q} \\
  \uncover<4-> { R \gets g^k } \\
  \uncover<5-> { c \gets H(R, m) \\ }
  \uncover<6-> { z \gets k + c \cdot \sk \\ }
  \uncover<7-> { \< \sendmessageright{top=\text{$(m, \sigma=(R, z))$}} \< \\ }
  \< \< \uncover<8-> { c \gets H(R, m) \\ }
  \< \< \uncover<9-> { R' \gets g^z \cdot \pk^{-c} \\ }
  \< \< \uncover<10-> { \text{Output } 1 \text{ if } R \stackrel{?}{=} R' \\ }
  \< \< \uncover<11-> { \text{Otherwise, output } 0 \\ }
}
}
\end{frame}


\begin{frame}
  \frametitle{ECDSA}

  \begin{itemize}
    \item<1-> Designed by Dan Bernstein to allow for a discrete-logarithm signature without infringing on the Schnorr patent. 
    \item[]
  \end{itemize}
\end{frame}

\begin{frame}
  \centering
  \small
\scalebox{0.9} {
\procedure{ECDSA }{
  \textbf{Signer}  \< \< \textbf{Verifier} \\
  \uncover<1-> { (\sk, \pk) \leftarrow \mathit{KeyGen()} \\ }
  \uncover<2-> { \< \sendmessageleft{top=\text{$m$}} \< \\ }
  \uncover<3-> { k \random \mathbb{Z}_q;\ R \gets g^k \in \mathbb{G}  \\ }
  \uncover<4-> { c \gets H(m) \\ }
  \uncover<5-> { z \gets k(c + \sk \cdot r ) \\ }
  \uncover<6-> { r \gets R.x \text{\algcom Derive the $x$-coordinate} \\ }
  %
  \uncover<7-> { \< \sendmessageright{top=\text{$(m, \sigma=(r, z))$}} \< \\ }
  \< \< \uncover<8-> { c \gets H(m) \\ }
  \< \< \uncover<9-> { u_1 \gets c \cdot z^{-1};\ u_2 \gets r \cdot z^{-1} \\ }
  \< \< \uncover<10-> { R' \gets g^{u_1} \cdot \pk^{u_2} \\ }
  \< \< \uncover<11-> { \text{Output } 1 \text{ if } r \stackrel{?}{=} R'.x;\ \text{ otherwise } 0 \\ }
}
}
\end{frame}


\begin{frame}
  \frametitle{EdDSA}

  \begin{itemize}
    \item<1-> Similar to single-party Schnorr, but with two tweaks. 
    \item[]
    \item<2-> First, the challenge additionally hashes in the public key to prevent malleability. 
    \item[]
    \item<3-> Second, nonce generation is deterministic with respect to $\sk$ and the message. 
  \end{itemize}
\end{frame}

\begin{frame}
  \centering
\scalebox{0.9} {
\procedure{Single-Party EdDSA Signing and Verification}{
  \textbf{Signer}  \< \< \textbf{Verifier} \\
  \uncover<1-> { (\sk, \pk) \leftarrow \mathit{KeyGen()} \\ }
  \uncover<2-> { \< \sendmessageleft{top=\text{$m$}} \< \\ }
  \uncover<3-> { k \gets H(\sk, m) \text{\algcom Deterministic nonce generation} } \\
  \uncover<4-> { R = g^k } \\
  \uncover<5-> { c = H(R, \pk, m) \\ }
  \uncover<6-> { z = k + c \cdot \sk \\ }
  \uncover<7-> { \< \sendmessageright{top=\text{$(m, \sigma=(R, z))$}} \< \\ }
  \< \< \uncover<8-> { c = H(R, \pk, m) \\ }
  \< \< \uncover<9-> { R' = g^z \cdot \pk^{-c} \\ }
  \< \< \uncover<10-> { \text{Output } 1 \text{ if } R \stackrel{?}{=} R' \\ }
  \< \< \uncover<10-> { \text{Otherwise, output } 0 \\ }
}
}
\end{frame}


\begin{frame}
  \huge 
  Threshold Signatures
\end{frame}


\begin{frame}
  \frametitle{Threshold Signatures: Joint Public \\ Key, Secret-Shared Private Key}

\begin{tikzpicture}
      \begin{pgfonlayer}{foreground}
    \node<2> [fill=yellow,draw=red,ultra thick, text width=.3\textwidth,anchor=north west,ellipse callout,text centered,callout
  absolute pointer = {(9.2,1)}] at (12,1) { The full secret
        is never reconstructed! Participants perform signing using only their secret
        share.};
      \end{pgfonlayer}
      \begin{pgfonlayer}{main}
      \node[person,shirt=black,female, minimum size=1.1cm] (p2) at (7.5,1) {
        $\includegraphics[width=.075\textwidth]{images/seckey.png}_\text{\bf
        Secret Share 1}$
      };
      \node[person,shirt=black, female, minimum size=1.1cm] (p6) at (9,-2) {
        $\includegraphics[width=.075\textwidth]{images/seckey.png}_\text{\bf
        Secret Share 2}$
      };
      \node[person,shirt=black,female, minimum size=1.1cm] (p7) at (13,1) {
        $\includegraphics[width=.075\textwidth]{images/seckey.png}_\text{\bf
        Secret Share 3}$
      };

      \end{pgfonlayer}

      \begin{pgfonlayer}{backbackground}
      \node[circle, minimum size = 5.4cm, color=lightgray,
        fill=lightgray]  (circ) at (10.5,-0.5){};
      \end{pgfonlayer}
      \begin{pgfonlayer}{background}
          \node[ellipse, draw=red, line width = 2pt,
          minimum width = 9.25cm, minimum height =3cm] at (10,0.5) {\small
          \bf Signing Set};
      \end{pgfonlayer}

       \node[outer sep = 2mm] (pubkey) at (18,-0.5)
       {
         $\includegraphics[width=.15\textwidth]{images/pubkey.png}_\text{\bf
         Public Key (1,2,3)}$  };

\end{tikzpicture}

\end{frame}


\begin{frame}
  \frametitle{Schnorr/EdDSA: FROST}

  \begin{itemize}
    \item<1-> Two-round threshold signing protocol, or single-round \\ protocol with
    preprocessing
    \item[]
    \item<2-> Signing operations are secure when performed concurrently,
      improving upon prior similar schemes.
    \item[]
    \item<3-> Signing can be performed with a threshold $t$ number of signers,
      where $t$ can be less than the number of possible signers $n$.
    \item[]
    \item<4-> Secure against an adversary that controls up to $t-1$ signers.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{FROST Keygen}

  \begin{itemize}
    \item<1-> Can be performed by either a trusted dealer or a Distributed Key
      Generation (DKG) Protocol
    \item[]
    \item<2-> The DKG is an $n$-wise Shamir Secret Sharing protocol, with each
      participant acting as a dealer
    \item[]
    \item<3> After KeyGen, each participant holds secret share $s_i$ and
      public key $Y_i$ (used for verification during signing) with joint public key $Y$.
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{FROST Sign}

  \begin{itemize}
    \item<1-> Can be performed in two rounds, or optimized to single round with
      preprocessing
    \item[]
    \item<2-> We show here with a signature aggregator, but can be
      performed without centralized roles
  \end{itemize}
\end{frame}



\begin{frame}
  \centering
\scalebox{1.0} {
\procedure{FROST Preprocess}{
  \textbf{Participant i}  \< \< \textbf{Commitment Server} \\
    \uncover<1-> { ((d_{ij}, e_{ij}), \dots) \random \mathbb{Z}_q^* \times \mathbb{Z}_q^* \\ }
    \uncover<2-> { (D_{ij}, E_{ij}) = (g^{d_{ij}}, g^{e_{ij}}) \\ }
    \uncover<3-> { \text{Store } ((d_{ij}, D_{ij}), (e_{ij}, E_{ij}), \dots) \\ }
    \uncover<4-> { \< \sendmessageright{top=\text{$((D_{ij}, E_{ij}), \dots)$}} \< \\ }
    \uncover<5-> { \< \< \text{Store } ((D_{ij}, E_{ij}), \dots) \\ }
}
}
\end{frame}

\begin{frame}
  \centering
\begin{tikzpicture}
\node at (0,0) {
\scalebox{0.9} {
\procedure{FROST Sign}{
  \textbf{Signer i}  \< \textbf{Signature Aggregator} \\
  \uncover<1-> {\< B=((1, D_1, E_1), \dots, (t, D_t, E_t)) \\}
  \uncover<2-> { \> \sendmessageleft{top=\text{$(m, B) $}}  \> \\ }
  \uncover<3-> { \rho_\ell = H_1(\ell, m, B), \ell \in S \\ }
  \uncover<4-> { R = \prod_{\ell \in S} D_\ell  \cdot ({E_\ell})^{\rho_\ell} \\ }
  \uncover<5-> { c = H_2(R, Y, m) \\ }
  \uncover<6-> { z_i = d_i + (e_i \cdot \rho_i) + \lambda_i \cdot s_i \cdot c \\ }
  \uncover<8-> { \> \sendmessageright{top=\text{$z_i$}} \> \\ }
  \uncover<9-> { \> \> \text{Publish } \sigma=(R, z=\sum z_i) }
}
}
};
\node<3> [fill=yellow,draw=red,ultra thick, text width=.3\textwidth,anchor=north west,ellipse callout,text centered,callout
  absolute pointer = {(-6.2,0.2)}] at (-1,-1) { ``binding value'' to bind signing shares to $\ell$, $m$, and $B$ };
\node<7> [fill=yellow,draw=red,ultra thick, text width=.3\textwidth,anchor=north west,ellipse callout,text centered,callout
  absolute pointer = {(-4.25,-1.5)}] at (1,1) { This step cannot be inverted by
  anyone who does not know $(d_i, e_i)$.};
  \node<7>[rectangle, draw=red, line width = 1.5pt,
  minimum width = 2cm, minimum height =.65cm] at (-5,-1.85) {};
\node<10> [fill=yellow,draw=red,ultra thick, text width=.3\textwidth,anchor=north west,ellipse callout,text centered,callout
  absolute pointer = {(3.2,-3.2)}] at (1,1) { Signature format and
  verification are identical to single-party Schnorr.};
\end{tikzpicture}
\end{frame}
























\begin{frame}
  \frametitle{Takeaways}

  \begin{itemize}
    \item TODO 
  \end{itemize}
\end{frame}


\end{document}



